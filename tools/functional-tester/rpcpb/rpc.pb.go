// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpcpb/rpc.proto

/*
	Package rpcpb is a generated protocol buffer package.

	It is generated from these files:
		rpcpb/rpc.proto

	It has these top-level messages:
		Etcd
		Member
		Tester
		Request
		Response
*/
package rpcpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Operation int32

const (
	Operation_NotStarted Operation = 0
	// InitialStartEtcd is only called to start etcd very first time.
	Operation_InitialStartEtcd Operation = 1
	// RestartEtcd is sent to restart killed etcd.
	Operation_RestartEtcd Operation = 2
	// KillEtcd pauses etcd process while keeping data directories
	// and previous etcd configurations.
	Operation_KillEtcd Operation = 3
	// FailArchive is sent when consistency check failed,
	// thus need to archive etcd data directories.
	Operation_FailArchive Operation = 4
	// DestroyEtcdAgent destroys etcd process, etcd data, and agent server.
	Operation_DestroyEtcdAgent        Operation = 5
	Operation_BlackholePeerPortTxRx   Operation = 100
	Operation_UnblackholePeerPortTxRx Operation = 101
	Operation_DelayPeerPortTxRx       Operation = 102
	Operation_UndelayPeerPortTxRx     Operation = 103
)

var Operation_name = map[int32]string{
	0:   "NotStarted",
	1:   "InitialStartEtcd",
	2:   "RestartEtcd",
	3:   "KillEtcd",
	4:   "FailArchive",
	5:   "DestroyEtcdAgent",
	100: "BlackholePeerPortTxRx",
	101: "UnblackholePeerPortTxRx",
	102: "DelayPeerPortTxRx",
	103: "UndelayPeerPortTxRx",
}
var Operation_value = map[string]int32{
	"NotStarted":              0,
	"InitialStartEtcd":        1,
	"RestartEtcd":             2,
	"KillEtcd":                3,
	"FailArchive":             4,
	"DestroyEtcdAgent":        5,
	"BlackholePeerPortTxRx":   100,
	"UnblackholePeerPortTxRx": 101,
	"DelayPeerPortTxRx":       102,
	"UndelayPeerPortTxRx":     103,
}

func (x Operation) String() string {
	return proto.EnumName(Operation_name, int32(x))
}
func (Operation) EnumDescriptor() ([]byte, []int) { return fileDescriptorRpc, []int{0} }

type FailureCase int32

const (
	FailureCase_KILL_ONE_FOLLOWER                                                FailureCase = 0
	FailureCase_KILL_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT                         FailureCase = 1
	FailureCase_KILL_LEADER                                                      FailureCase = 2
	FailureCase_KILL_LEADER_UNTIL_TRIGGER_SNAPSHOT                               FailureCase = 3
	FailureCase_KILL_QUORUM                                                      FailureCase = 4
	FailureCase_KILL_ALL                                                         FailureCase = 5
	FailureCase_BLACKHOLE_PEER_PORT_TX_RX_ONE_FOLLOWER                           FailureCase = 100
	FailureCase_BLACKHOLE_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT    FailureCase = 101
	FailureCase_BLACKHOLE_PEER_PORT_TX_RX_LEADER                                 FailureCase = 102
	FailureCase_BLACKHOLE_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT          FailureCase = 103
	FailureCase_BLACKHOLE_PEER_PORT_TX_RX_QUORUM                                 FailureCase = 104
	FailureCase_BLACKHOLE_PEER_PORT_TX_RX_ALL                                    FailureCase = 105
	FailureCase_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER                               FailureCase = 200
	FailureCase_RANDOM_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER                        FailureCase = 201
	FailureCase_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT        FailureCase = 202
	FailureCase_RANDOM_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT FailureCase = 203
	FailureCase_DELAY_PEER_PORT_TX_RX_LEADER                                     FailureCase = 204
	FailureCase_RANDOM_DELAY_PEER_PORT_TX_RX_LEADER                              FailureCase = 205
	FailureCase_DELAY_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT              FailureCase = 206
	FailureCase_RANDOM_DELAY_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT       FailureCase = 207
	FailureCase_DELAY_PEER_PORT_TX_RX_QUORUM                                     FailureCase = 208
	FailureCase_RANDOM_DELAY_PEER_PORT_TX_RX_QUORUM                              FailureCase = 209
	FailureCase_DELAY_PEER_PORT_TX_RX_ALL                                        FailureCase = 210
	FailureCase_RANDOM_DELAY_PEER_PORT_TX_RX_ALL                                 FailureCase = 211
	// NO_FAIL_WITH_STRESS runs no-op failure injection for specified period
	// while stressers are still sending requests.
	FailureCase_NO_FAIL_WITH_STRESS FailureCase = 300
	// NO_FAIL_WITH_NO_STRESS_FOR_LIVENESS runs no-op failure injection
	// with all stressers stopped.
	FailureCase_NO_FAIL_WITH_NO_STRESS_FOR_LIVENESS FailureCase = 301
	FailureCase_FAILPOINTS                          FailureCase = 400
	FailureCase_EXTERNAL                            FailureCase = 500
)

var FailureCase_name = map[int32]string{
	0:   "KILL_ONE_FOLLOWER",
	1:   "KILL_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT",
	2:   "KILL_LEADER",
	3:   "KILL_LEADER_UNTIL_TRIGGER_SNAPSHOT",
	4:   "KILL_QUORUM",
	5:   "KILL_ALL",
	100: "BLACKHOLE_PEER_PORT_TX_RX_ONE_FOLLOWER",
	101: "BLACKHOLE_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT",
	102: "BLACKHOLE_PEER_PORT_TX_RX_LEADER",
	103: "BLACKHOLE_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT",
	104: "BLACKHOLE_PEER_PORT_TX_RX_QUORUM",
	105: "BLACKHOLE_PEER_PORT_TX_RX_ALL",
	200: "DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER",
	201: "RANDOM_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER",
	202: "DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT",
	203: "RANDOM_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT",
	204: "DELAY_PEER_PORT_TX_RX_LEADER",
	205: "RANDOM_DELAY_PEER_PORT_TX_RX_LEADER",
	206: "DELAY_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT",
	207: "RANDOM_DELAY_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT",
	208: "DELAY_PEER_PORT_TX_RX_QUORUM",
	209: "RANDOM_DELAY_PEER_PORT_TX_RX_QUORUM",
	210: "DELAY_PEER_PORT_TX_RX_ALL",
	211: "RANDOM_DELAY_PEER_PORT_TX_RX_ALL",
	300: "NO_FAIL_WITH_STRESS",
	301: "NO_FAIL_WITH_NO_STRESS_FOR_LIVENESS",
	400: "FAILPOINTS",
	500: "EXTERNAL",
}
var FailureCase_value = map[string]int32{
	"KILL_ONE_FOLLOWER":                        0,
	"KILL_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT": 1,
	"KILL_LEADER":                              2,
	"KILL_LEADER_UNTIL_TRIGGER_SNAPSHOT":       3,
	"KILL_QUORUM":                              4,
	"KILL_ALL":                                 5,
	"BLACKHOLE_PEER_PORT_TX_RX_ONE_FOLLOWER":                           100,
	"BLACKHOLE_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT":    101,
	"BLACKHOLE_PEER_PORT_TX_RX_LEADER":                                 102,
	"BLACKHOLE_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT":          103,
	"BLACKHOLE_PEER_PORT_TX_RX_QUORUM":                                 104,
	"BLACKHOLE_PEER_PORT_TX_RX_ALL":                                    105,
	"DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER":                               200,
	"RANDOM_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER":                        201,
	"DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT":        202,
	"RANDOM_DELAY_PEER_PORT_TX_RX_ONE_FOLLOWER_UNTIL_TRIGGER_SNAPSHOT": 203,
	"DELAY_PEER_PORT_TX_RX_LEADER":                                     204,
	"RANDOM_DELAY_PEER_PORT_TX_RX_LEADER":                              205,
	"DELAY_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT":              206,
	"RANDOM_DELAY_PEER_PORT_TX_RX_LEADER_UNTIL_TRIGGER_SNAPSHOT":       207,
	"DELAY_PEER_PORT_TX_RX_QUORUM":                                     208,
	"RANDOM_DELAY_PEER_PORT_TX_RX_QUORUM":                              209,
	"DELAY_PEER_PORT_TX_RX_ALL":                                        210,
	"RANDOM_DELAY_PEER_PORT_TX_RX_ALL":                                 211,
	"NO_FAIL_WITH_STRESS":                                              300,
	"NO_FAIL_WITH_NO_STRESS_FOR_LIVENESS":                              301,
	"FAILPOINTS":                                                       400,
	"EXTERNAL":                                                         500,
}

func (x FailureCase) String() string {
	return proto.EnumName(FailureCase_name, int32(x))
}
func (FailureCase) EnumDescriptor() ([]byte, []int) { return fileDescriptorRpc, []int{1} }

type StressType int32

const (
	StressType_KV                StressType = 0
	StressType_LEASE             StressType = 1
	StressType_ELECTION_RUNNER   StressType = 2
	StressType_WATCH_RUNNER      StressType = 3
	StressType_LOCK_RACER_RUNNER StressType = 4
	StressType_LEASE_RUNNER      StressType = 5
)

var StressType_name = map[int32]string{
	0: "KV",
	1: "LEASE",
	2: "ELECTION_RUNNER",
	3: "WATCH_RUNNER",
	4: "LOCK_RACER_RUNNER",
	5: "LEASE_RUNNER",
}
var StressType_value = map[string]int32{
	"KV":                0,
	"LEASE":             1,
	"ELECTION_RUNNER":   2,
	"WATCH_RUNNER":      3,
	"LOCK_RACER_RUNNER": 4,
	"LEASE_RUNNER":      5,
}

func (x StressType) String() string {
	return proto.EnumName(StressType_name, int32(x))
}
func (StressType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRpc, []int{2} }

type Etcd struct {
	Name    string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty" yaml:"name"`
	DataDir string `protobuf:"bytes,2,opt,name=DataDir,proto3" json:"DataDir,omitempty" yaml:"data-dir"`
	WALDir  string `protobuf:"bytes,3,opt,name=WALDir,proto3" json:"WALDir,omitempty" yaml:"wal-dir"`
	// HeartbeatIntervalMs is the time (in milliseconds) of a heartbeat interval.
	// Default value is 100, which is 100ms.
	HeartbeatIntervalMs int64 `protobuf:"varint,11,opt,name=HeartbeatIntervalMs,proto3" json:"HeartbeatIntervalMs,omitempty" yaml:"heartbeat-interval"`
	// ElectionTimeoutMs is the time (in milliseconds) for an election to timeout.
	// Default value is 1000, which is 1s.
	ElectionTimeoutMs   int64    `protobuf:"varint,12,opt,name=ElectionTimeoutMs,proto3" json:"ElectionTimeoutMs,omitempty" yaml:"election-timeout"`
	ListenClientURLs    []string `protobuf:"bytes,21,rep,name=ListenClientURLs" json:"ListenClientURLs,omitempty" yaml:"listen-client-urls"`
	AdvertiseClientURLs []string `protobuf:"bytes,22,rep,name=AdvertiseClientURLs" json:"AdvertiseClientURLs,omitempty" yaml:"advertise-client-urls"`
	ClientAutoTLS       bool     `protobuf:"varint,23,opt,name=ClientAutoTLS,proto3" json:"ClientAutoTLS,omitempty" yaml:"auto-tls"`
	ClientCertAuth      bool     `protobuf:"varint,24,opt,name=ClientCertAuth,proto3" json:"ClientCertAuth,omitempty" yaml:"client-cert-auth"`
	ClientCertFile      string   `protobuf:"bytes,25,opt,name=ClientCertFile,proto3" json:"ClientCertFile,omitempty" yaml:"cert-file"`
	ClientKeyFile       string   `protobuf:"bytes,26,opt,name=ClientKeyFile,proto3" json:"ClientKeyFile,omitempty" yaml:"key-file"`
	ClientTrustedCAFile string   `protobuf:"bytes,27,opt,name=ClientTrustedCAFile,proto3" json:"ClientTrustedCAFile,omitempty" yaml:"trusted-ca-file"`
	ListenPeerURLs      []string `protobuf:"bytes,31,rep,name=ListenPeerURLs" json:"ListenPeerURLs,omitempty" yaml:"listen-peer-urls"`
	AdvertisePeerURLs   []string `protobuf:"bytes,32,rep,name=AdvertisePeerURLs" json:"AdvertisePeerURLs,omitempty" yaml:"initial-advertise-peer-urls"`
	PeerAutoTLS         bool     `protobuf:"varint,33,opt,name=PeerAutoTLS,proto3" json:"PeerAutoTLS,omitempty" yaml:"peer-auto-tls"`
	PeerClientCertAuth  bool     `protobuf:"varint,34,opt,name=PeerClientCertAuth,proto3" json:"PeerClientCertAuth,omitempty" yaml:"peer-client-cert-auth"`
	PeerCertFile        string   `protobuf:"bytes,35,opt,name=PeerCertFile,proto3" json:"PeerCertFile,omitempty" yaml:"peer-cert-file"`
	PeerKeyFile         string   `protobuf:"bytes,36,opt,name=PeerKeyFile,proto3" json:"PeerKeyFile,omitempty" yaml:"peer-key-file"`
	PeerTrustedCAFile   string   `protobuf:"bytes,37,opt,name=PeerTrustedCAFile,proto3" json:"PeerTrustedCAFile,omitempty" yaml:"peer-trusted-ca-file"`
	InitialCluster      string   `protobuf:"bytes,41,opt,name=InitialCluster,proto3" json:"InitialCluster,omitempty" yaml:"initial-cluster"`
	InitialClusterState string   `protobuf:"bytes,42,opt,name=InitialClusterState,proto3" json:"InitialClusterState,omitempty" yaml:"initial-cluster-state"`
	InitialClusterToken string   `protobuf:"bytes,43,opt,name=InitialClusterToken,proto3" json:"InitialClusterToken,omitempty" yaml:"initial-cluster-token"`
	SnapshotCount       int64    `protobuf:"varint,51,opt,name=SnapshotCount,proto3" json:"SnapshotCount,omitempty" yaml:"snapshot-count"`
	QuotaBackendBytes   int64    `protobuf:"varint,52,opt,name=QuotaBackendBytes,proto3" json:"QuotaBackendBytes,omitempty" yaml:"quota-backend-bytes"`
	PreVote             bool     `protobuf:"varint,63,opt,name=PreVote,proto3" json:"PreVote,omitempty" yaml:"pre-vote"`
	InitialCorruptCheck bool     `protobuf:"varint,64,opt,name=InitialCorruptCheck,proto3" json:"InitialCorruptCheck,omitempty" yaml:"initial-corrupt-check"`
}

func (m *Etcd) Reset()                    { *m = Etcd{} }
func (m *Etcd) String() string            { return proto.CompactTextString(m) }
func (*Etcd) ProtoMessage()               {}
func (*Etcd) Descriptor() ([]byte, []int) { return fileDescriptorRpc, []int{0} }

type Member struct {
	// EtcdExecPath is the executable etcd binary path in agent server.
	EtcdExecPath string `protobuf:"bytes,1,opt,name=EtcdExecPath,proto3" json:"EtcdExecPath,omitempty" yaml:"etcd-exec-path"`
	// AgentAddr is the agent HTTP server address.
	AgentAddr string `protobuf:"bytes,11,opt,name=AgentAddr,proto3" json:"AgentAddr,omitempty" yaml:"agent-addr"`
	// FailpointHTTPAddr is the agent's failpoints HTTP server address.
	FailpointHTTPAddr string `protobuf:"bytes,12,opt,name=FailpointHTTPAddr,proto3" json:"FailpointHTTPAddr,omitempty" yaml:"failpoint-http-addr"`
	// BaseDir is the base directory where all logs and etcd data are stored.
	BaseDir string `protobuf:"bytes,101,opt,name=BaseDir,proto3" json:"BaseDir,omitempty" yaml:"base-dir"`
	// EtcdLogPath is the log file to store current etcd server logs.
	EtcdLogPath string `protobuf:"bytes,102,opt,name=EtcdLogPath,proto3" json:"EtcdLogPath,omitempty" yaml:"etcd-log-path"`
	// EtcdClientTLS is true when client traffic needs to be encrypted.
	EtcdClientTLS bool `protobuf:"varint,201,opt,name=EtcdClientTLS,proto3" json:"EtcdClientTLS,omitempty" yaml:"etcd-client-tls"`
	// EtcdClientProxy is true when client traffic needs to be proxied.
	// If true, listen client URL port must be different than advertise client URL port.
	EtcdClientProxy bool `protobuf:"varint,202,opt,name=EtcdClientProxy,proto3" json:"EtcdClientProxy,omitempty" yaml:"etcd-client-proxy"`
	// EtcdPeerProxy is true when peer traffic needs to be proxied.
	// If true, listen peer URL port must be different than advertise peer URL port.
	EtcdPeerProxy bool `protobuf:"varint,203,opt,name=EtcdPeerProxy,proto3" json:"EtcdPeerProxy,omitempty" yaml:"etcd-peer-proxy"`
	// EtcdClientEndpoint is the etcd client endpoint.
	EtcdClientEndpoint string `protobuf:"bytes,204,opt,name=EtcdClientEndpoint,proto3" json:"EtcdClientEndpoint,omitempty" yaml:"etcd-client-endpoint"`
	// Etcd defines etcd binary configuration flags.
	Etcd *Etcd `protobuf:"bytes,301,opt,name=Etcd" json:"Etcd,omitempty" yaml:"etcd"`
	// ClientCertData contains cert file contents from this member's etcd server.
	ClientCertData string `protobuf:"bytes,401,opt,name=ClientCertData,proto3" json:"ClientCertData,omitempty" yaml:"client-cert-data"`
	// ClientKeyData contains key file contents from this member's etcd server.
	ClientKeyData string `protobuf:"bytes,402,opt,name=ClientKeyData,proto3" json:"ClientKeyData,omitempty" yaml:"client-key-data"`
	// ClientTrustedCAData contains trusted CA file contents from this member's etcd server.
	ClientTrustedCAData string `protobuf:"bytes,403,opt,name=ClientTrustedCAData,proto3" json:"ClientTrustedCAData,omitempty" yaml:"client-trusted-ca-data"`
	// PeerCertData contains cert file contents from this member's etcd server.
	PeerCertData string `protobuf:"bytes,501,opt,name=PeerCertData,proto3" json:"PeerCertData,omitempty" yaml:"peer-cert-data"`
	// PeerKeyData contains key file contents from this member's etcd server.
	PeerKeyData string `protobuf:"bytes,502,opt,name=PeerKeyData,proto3" json:"PeerKeyData,omitempty" yaml:"peer-key-data"`
	// PeerTrustedCAData contains trusted CA file contents from this member's etcd server.
	PeerTrustedCAData string `protobuf:"bytes,503,opt,name=PeerTrustedCAData,proto3" json:"PeerTrustedCAData,omitempty" yaml:"peer-trusted-ca-data"`
}

func (m *Member) Reset()                    { *m = Member{} }
func (m *Member) String() string            { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()               {}
func (*Member) Descriptor() ([]byte, []int) { return fileDescriptorRpc, []int{1} }

type Tester struct {
	TesterNetwork string `protobuf:"bytes,1,opt,name=TesterNetwork,proto3" json:"TesterNetwork,omitempty" yaml:"tester-network"`
	TesterAddr    string `protobuf:"bytes,2,opt,name=TesterAddr,proto3" json:"TesterAddr,omitempty" yaml:"tester-addr"`
	// DelayLatencyMsRv is the delay latency in milliseconds,
	// to inject to simulated slow network.
	DelayLatencyMs uint32 `protobuf:"varint,11,opt,name=DelayLatencyMs,proto3" json:"DelayLatencyMs,omitempty" yaml:"delay-latency-ms"`
	// DelayLatencyMsRv is the delay latency random variable in milliseconds.
	DelayLatencyMsRv uint32 `protobuf:"varint,12,opt,name=DelayLatencyMsRv,proto3" json:"DelayLatencyMsRv,omitempty" yaml:"delay-latency-ms-rv"`
	// UpdatedDelayLatencyMs is the update delay latency in milliseconds,
	// to inject to simulated slow network. It's the final latency to apply,
	// in case the latency numbers are randomly generated from given delay latency field.
	UpdatedDelayLatencyMs uint32 `protobuf:"varint,13,opt,name=UpdatedDelayLatencyMs,proto3" json:"UpdatedDelayLatencyMs,omitempty" yaml:"updated-delay-latency-ms"`
	// RoundLimit is the limit of rounds to run failure set (-1 to run without limits).
	RoundLimit int32 `protobuf:"varint,21,opt,name=RoundLimit,proto3" json:"RoundLimit,omitempty" yaml:"round-limit"`
	// ExitOnFailure is true, then exit tester on first failure.
	ExitOnFailure bool `protobuf:"varint,22,opt,name=ExitOnFailure,proto3" json:"ExitOnFailure,omitempty" yaml:"exit-on-failure"`
	// ConsistencyCheck is true to check consistency (revision, hash).
	ConsistencyCheck bool `protobuf:"varint,23,opt,name=ConsistencyCheck,proto3" json:"ConsistencyCheck,omitempty" yaml:"consistency-check"`
	// EnablePprof is true to enable profiler.
	EnablePprof bool `protobuf:"varint,24,opt,name=EnablePprof,proto3" json:"EnablePprof,omitempty" yaml:"enable-pprof"`
	// FailureCases is the selected test cases to schedule.
	// If empty, run all failure cases.
	FailureCases []string `protobuf:"bytes,31,rep,name=FailureCases" json:"FailureCases,omitempty" yaml:"failure-cases"`
	// FailureDelayMs is the delay duration after failure is injected.
	// Useful when triggering snapshot or no-op failure cases.
	FailureDelayMs uint32 `protobuf:"varint,32,opt,name=FailureDelayMs,proto3" json:"FailureDelayMs,omitempty" yaml:"failure-delay-ms"`
	// FailureShuffle is true to randomize failure injecting order.
	FailureShuffle bool `protobuf:"varint,33,opt,name=FailureShuffle,proto3" json:"FailureShuffle,omitempty" yaml:"failure-shuffle"`
	// FailpointCommands is the list of "gofail" commands (e.g. panic("etcd-tester"),1*sleep(1000)).
	FailpointCommands []string `protobuf:"bytes,34,rep,name=FailpointCommands" json:"FailpointCommands,omitempty" yaml:"failpoint-commands"`
	// RunnerExecPath is a path of etcd-runner binary.
	RunnerExecPath string `protobuf:"bytes,41,opt,name=RunnerExecPath,proto3" json:"RunnerExecPath,omitempty" yaml:"runner-exec-path"`
	// ExternalExecPath is a path of script for enabling/disabling an external fault injector.
	ExternalExecPath string `protobuf:"bytes,42,opt,name=ExternalExecPath,proto3" json:"ExternalExecPath,omitempty" yaml:"external-exec-path"`
	// StressTypes is the list of stresser names:
	// keys, lease, nop, election-runner, watch-runner, lock-racer-runner, lease-runner.
	StressTypes []string `protobuf:"bytes,101,rep,name=StressTypes" json:"StressTypes,omitempty" yaml:"stress-types"`
	// StressKeySize is the size of each small key written into etcd.
	StressKeySize int32 `protobuf:"varint,102,opt,name=StressKeySize,proto3" json:"StressKeySize,omitempty" yaml:"stress-key-size"`
	// StressKeySizeLarge is the size of each large key written into etcd.
	StressKeySizeLarge int32 `protobuf:"varint,103,opt,name=StressKeySizeLarge,proto3" json:"StressKeySizeLarge,omitempty" yaml:"stress-key-size-large"`
	// StressKeySuffixRange is the count of key range written into etcd.
	// Stress keys are created with "fmt.Sprintf("foo%016x", rand.Intn(keySuffixRange)".
	StressKeySuffixRange int32 `protobuf:"varint,104,opt,name=StressKeySuffixRange,proto3" json:"StressKeySuffixRange,omitempty" yaml:"stress-key-suffix-range"`
	// StressKeySuffixRangeTxn is the count of key range written into etcd txn (max 100).
	// Stress keys are created with "fmt.Sprintf("/k%03d", i)".
	StressKeySuffixRangeTxn int32 `protobuf:"varint,105,opt,name=StressKeySuffixRangeTxn,proto3" json:"StressKeySuffixRangeTxn,omitempty" yaml:"stress-key-suffix-range-txn"`
	// StressKeyTxnOps is the number of operations per a transaction (max 64).
	StressKeyTxnOps int32 `protobuf:"varint,106,opt,name=StressKeyTxnOps,proto3" json:"StressKeyTxnOps,omitempty" yaml:"stress-key-txn-ops"`
	// StressClients is the number of concurrent stressing clients
	// with "one" shared TCP connection.
	StressClients int32 `protobuf:"varint,201,opt,name=StressClients,proto3" json:"StressClients,omitempty" yaml:"stress-clients"`
	// StressQPS is the maximum number of stresser requests per second.
	StressQPS int32 `protobuf:"varint,202,opt,name=StressQPS,proto3" json:"StressQPS,omitempty" yaml:"stress-qps"`
}

func (m *Tester) Reset()                    { *m = Tester{} }
func (m *Tester) String() string            { return proto.CompactTextString(m) }
func (*Tester) ProtoMessage()               {}
func (*Tester) Descriptor() ([]byte, []int) { return fileDescriptorRpc, []int{2} }

type Request struct {
	Operation Operation `protobuf:"varint,1,opt,name=Operation,proto3,enum=rpcpb.Operation" json:"Operation,omitempty"`
	// Member contains the same Member object from tester configuration.
	Member *Member `protobuf:"bytes,2,opt,name=Member" json:"Member,omitempty"`
	// Tester contains tester configuration.
	Tester *Tester `protobuf:"bytes,3,opt,name=Tester" json:"Tester,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorRpc, []int{3} }

type Response struct {
	Success bool   `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	Status  string `protobuf:"bytes,2,opt,name=Status,proto3" json:"Status,omitempty"`
	// Member contains the same Member object from tester request.
	Member *Member `protobuf:"bytes,3,opt,name=Member" json:"Member,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorRpc, []int{4} }

func init() {
	proto.RegisterType((*Etcd)(nil), "rpcpb.Etcd")
	proto.RegisterType((*Member)(nil), "rpcpb.Member")
	proto.RegisterType((*Tester)(nil), "rpcpb.Tester")
	proto.RegisterType((*Request)(nil), "rpcpb.Request")
	proto.RegisterType((*Response)(nil), "rpcpb.Response")
	proto.RegisterEnum("rpcpb.Operation", Operation_name, Operation_value)
	proto.RegisterEnum("rpcpb.FailureCase", FailureCase_name, FailureCase_value)
	proto.RegisterEnum("rpcpb.StressType", StressType_name, StressType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Transport service

type TransportClient interface {
	Transport(ctx context.Context, opts ...grpc.CallOption) (Transport_TransportClient, error)
}

type transportClient struct {
	cc *grpc.ClientConn
}

func NewTransportClient(cc *grpc.ClientConn) TransportClient {
	return &transportClient{cc}
}

func (c *transportClient) Transport(ctx context.Context, opts ...grpc.CallOption) (Transport_TransportClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Transport_serviceDesc.Streams[0], c.cc, "/rpcpb.Transport/Transport", opts...)
	if err != nil {
		return nil, err
	}
	x := &transportTransportClient{stream}
	return x, nil
}

type Transport_TransportClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type transportTransportClient struct {
	grpc.ClientStream
}

func (x *transportTransportClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *transportTransportClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Transport service

type TransportServer interface {
	Transport(Transport_TransportServer) error
}

func RegisterTransportServer(s *grpc.Server, srv TransportServer) {
	s.RegisterService(&_Transport_serviceDesc, srv)
}

func _Transport_Transport_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TransportServer).Transport(&transportTransportServer{stream})
}

type Transport_TransportServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type transportTransportServer struct {
	grpc.ServerStream
}

func (x *transportTransportServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *transportTransportServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Transport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpcpb.Transport",
	HandlerType: (*TransportServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Transport",
			Handler:       _Transport_Transport_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "rpcpb/rpc.proto",
}

func (m *Etcd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Etcd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DataDir) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.DataDir)))
		i += copy(dAtA[i:], m.DataDir)
	}
	if len(m.WALDir) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.WALDir)))
		i += copy(dAtA[i:], m.WALDir)
	}
	if m.HeartbeatIntervalMs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.HeartbeatIntervalMs))
	}
	if m.ElectionTimeoutMs != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.ElectionTimeoutMs))
	}
	if len(m.ListenClientURLs) > 0 {
		for _, s := range m.ListenClientURLs {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AdvertiseClientURLs) > 0 {
		for _, s := range m.AdvertiseClientURLs {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ClientAutoTLS {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.ClientAutoTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClientCertAuth {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.ClientCertAuth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ClientCertFile) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ClientCertFile)))
		i += copy(dAtA[i:], m.ClientCertFile)
	}
	if len(m.ClientKeyFile) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ClientKeyFile)))
		i += copy(dAtA[i:], m.ClientKeyFile)
	}
	if len(m.ClientTrustedCAFile) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ClientTrustedCAFile)))
		i += copy(dAtA[i:], m.ClientTrustedCAFile)
	}
	if len(m.ListenPeerURLs) > 0 {
		for _, s := range m.ListenPeerURLs {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AdvertisePeerURLs) > 0 {
		for _, s := range m.AdvertisePeerURLs {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PeerAutoTLS {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.PeerAutoTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PeerClientCertAuth {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.PeerClientCertAuth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PeerCertFile) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerCertFile)))
		i += copy(dAtA[i:], m.PeerCertFile)
	}
	if len(m.PeerKeyFile) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerKeyFile)))
		i += copy(dAtA[i:], m.PeerKeyFile)
	}
	if len(m.PeerTrustedCAFile) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerTrustedCAFile)))
		i += copy(dAtA[i:], m.PeerTrustedCAFile)
	}
	if len(m.InitialCluster) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.InitialCluster)))
		i += copy(dAtA[i:], m.InitialCluster)
	}
	if len(m.InitialClusterState) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.InitialClusterState)))
		i += copy(dAtA[i:], m.InitialClusterState)
	}
	if len(m.InitialClusterToken) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.InitialClusterToken)))
		i += copy(dAtA[i:], m.InitialClusterToken)
	}
	if m.SnapshotCount != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.SnapshotCount))
	}
	if m.QuotaBackendBytes != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.QuotaBackendBytes))
	}
	if m.PreVote {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x3
		i++
		if m.PreVote {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InitialCorruptCheck {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x4
		i++
		if m.InitialCorruptCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EtcdExecPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.EtcdExecPath)))
		i += copy(dAtA[i:], m.EtcdExecPath)
	}
	if len(m.AgentAddr) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.AgentAddr)))
		i += copy(dAtA[i:], m.AgentAddr)
	}
	if len(m.FailpointHTTPAddr) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.FailpointHTTPAddr)))
		i += copy(dAtA[i:], m.FailpointHTTPAddr)
	}
	if len(m.BaseDir) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.BaseDir)))
		i += copy(dAtA[i:], m.BaseDir)
	}
	if len(m.EtcdLogPath) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.EtcdLogPath)))
		i += copy(dAtA[i:], m.EtcdLogPath)
	}
	if m.EtcdClientTLS {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0xc
		i++
		if m.EtcdClientTLS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EtcdClientProxy {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0xc
		i++
		if m.EtcdClientProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EtcdPeerProxy {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0xc
		i++
		if m.EtcdPeerProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EtcdClientEndpoint) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.EtcdClientEndpoint)))
		i += copy(dAtA[i:], m.EtcdClientEndpoint)
	}
	if m.Etcd != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Etcd.Size()))
		n1, err := m.Etcd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.ClientCertData) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ClientCertData)))
		i += copy(dAtA[i:], m.ClientCertData)
	}
	if len(m.ClientKeyData) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ClientKeyData)))
		i += copy(dAtA[i:], m.ClientKeyData)
	}
	if len(m.ClientTrustedCAData) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ClientTrustedCAData)))
		i += copy(dAtA[i:], m.ClientTrustedCAData)
	}
	if len(m.PeerCertData) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1f
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerCertData)))
		i += copy(dAtA[i:], m.PeerCertData)
	}
	if len(m.PeerKeyData) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1f
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerKeyData)))
		i += copy(dAtA[i:], m.PeerKeyData)
	}
	if len(m.PeerTrustedCAData) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1f
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PeerTrustedCAData)))
		i += copy(dAtA[i:], m.PeerTrustedCAData)
	}
	return i, nil
}

func (m *Tester) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tester) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TesterNetwork) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TesterNetwork)))
		i += copy(dAtA[i:], m.TesterNetwork)
	}
	if len(m.TesterAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TesterAddr)))
		i += copy(dAtA[i:], m.TesterAddr)
	}
	if m.DelayLatencyMs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.DelayLatencyMs))
	}
	if m.DelayLatencyMsRv != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.DelayLatencyMsRv))
	}
	if m.UpdatedDelayLatencyMs != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.UpdatedDelayLatencyMs))
	}
	if m.RoundLimit != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.RoundLimit))
	}
	if m.ExitOnFailure {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.ExitOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConsistencyCheck {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		if m.ConsistencyCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnablePprof {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.EnablePprof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FailureCases) > 0 {
		for _, s := range m.FailureCases {
			dAtA[i] = 0xfa
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.FailureDelayMs != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.FailureDelayMs))
	}
	if m.FailureShuffle {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.FailureShuffle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FailpointCommands) > 0 {
		for _, s := range m.FailpointCommands {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RunnerExecPath) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.RunnerExecPath)))
		i += copy(dAtA[i:], m.RunnerExecPath)
	}
	if len(m.ExternalExecPath) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ExternalExecPath)))
		i += copy(dAtA[i:], m.ExternalExecPath)
	}
	if len(m.StressTypes) > 0 {
		for _, s := range m.StressTypes {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x6
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.StressKeySize != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressKeySize))
	}
	if m.StressKeySizeLarge != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressKeySizeLarge))
	}
	if m.StressKeySuffixRange != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressKeySuffixRange))
	}
	if m.StressKeySuffixRangeTxn != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressKeySuffixRangeTxn))
	}
	if m.StressKeyTxnOps != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressKeyTxnOps))
	}
	if m.StressClients != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressClients))
	}
	if m.StressQPS != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StressQPS))
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Operation))
	}
	if m.Member != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Member.Size()))
		n2, err := m.Member.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Tester != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Tester.Size()))
		n3, err := m.Tester.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.Member != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Member.Size()))
		n4, err := m.Member.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Etcd) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.DataDir)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.WALDir)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.HeartbeatIntervalMs != 0 {
		n += 1 + sovRpc(uint64(m.HeartbeatIntervalMs))
	}
	if m.ElectionTimeoutMs != 0 {
		n += 1 + sovRpc(uint64(m.ElectionTimeoutMs))
	}
	if len(m.ListenClientURLs) > 0 {
		for _, s := range m.ListenClientURLs {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	if len(m.AdvertiseClientURLs) > 0 {
		for _, s := range m.AdvertiseClientURLs {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	if m.ClientAutoTLS {
		n += 3
	}
	if m.ClientCertAuth {
		n += 3
	}
	l = len(m.ClientCertFile)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.ClientKeyFile)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.ClientTrustedCAFile)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	if len(m.ListenPeerURLs) > 0 {
		for _, s := range m.ListenPeerURLs {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	if len(m.AdvertisePeerURLs) > 0 {
		for _, s := range m.AdvertisePeerURLs {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	if m.PeerAutoTLS {
		n += 3
	}
	if m.PeerClientCertAuth {
		n += 3
	}
	l = len(m.PeerCertFile)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.PeerKeyFile)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.PeerTrustedCAFile)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.InitialCluster)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.InitialClusterState)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.InitialClusterToken)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	if m.SnapshotCount != 0 {
		n += 2 + sovRpc(uint64(m.SnapshotCount))
	}
	if m.QuotaBackendBytes != 0 {
		n += 2 + sovRpc(uint64(m.QuotaBackendBytes))
	}
	if m.PreVote {
		n += 3
	}
	if m.InitialCorruptCheck {
		n += 3
	}
	return n
}

func (m *Member) Size() (n int) {
	var l int
	_ = l
	l = len(m.EtcdExecPath)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.AgentAddr)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.FailpointHTTPAddr)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.BaseDir)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.EtcdLogPath)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	if m.EtcdClientTLS {
		n += 3
	}
	if m.EtcdClientProxy {
		n += 3
	}
	if m.EtcdPeerProxy {
		n += 3
	}
	l = len(m.EtcdClientEndpoint)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	if m.Etcd != nil {
		l = m.Etcd.Size()
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.ClientCertData)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.ClientKeyData)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.ClientTrustedCAData)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.PeerCertData)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.PeerKeyData)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.PeerTrustedCAData)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	return n
}

func (m *Tester) Size() (n int) {
	var l int
	_ = l
	l = len(m.TesterNetwork)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.TesterAddr)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.DelayLatencyMs != 0 {
		n += 1 + sovRpc(uint64(m.DelayLatencyMs))
	}
	if m.DelayLatencyMsRv != 0 {
		n += 1 + sovRpc(uint64(m.DelayLatencyMsRv))
	}
	if m.UpdatedDelayLatencyMs != 0 {
		n += 1 + sovRpc(uint64(m.UpdatedDelayLatencyMs))
	}
	if m.RoundLimit != 0 {
		n += 2 + sovRpc(uint64(m.RoundLimit))
	}
	if m.ExitOnFailure {
		n += 3
	}
	if m.ConsistencyCheck {
		n += 3
	}
	if m.EnablePprof {
		n += 3
	}
	if len(m.FailureCases) > 0 {
		for _, s := range m.FailureCases {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	if m.FailureDelayMs != 0 {
		n += 2 + sovRpc(uint64(m.FailureDelayMs))
	}
	if m.FailureShuffle {
		n += 3
	}
	if len(m.FailpointCommands) > 0 {
		for _, s := range m.FailpointCommands {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.RunnerExecPath)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.ExternalExecPath)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	if len(m.StressTypes) > 0 {
		for _, s := range m.StressTypes {
			l = len(s)
			n += 2 + l + sovRpc(uint64(l))
		}
	}
	if m.StressKeySize != 0 {
		n += 2 + sovRpc(uint64(m.StressKeySize))
	}
	if m.StressKeySizeLarge != 0 {
		n += 2 + sovRpc(uint64(m.StressKeySizeLarge))
	}
	if m.StressKeySuffixRange != 0 {
		n += 2 + sovRpc(uint64(m.StressKeySuffixRange))
	}
	if m.StressKeySuffixRangeTxn != 0 {
		n += 2 + sovRpc(uint64(m.StressKeySuffixRangeTxn))
	}
	if m.StressKeyTxnOps != 0 {
		n += 2 + sovRpc(uint64(m.StressKeyTxnOps))
	}
	if m.StressClients != 0 {
		n += 2 + sovRpc(uint64(m.StressClients))
	}
	if m.StressQPS != 0 {
		n += 2 + sovRpc(uint64(m.StressQPS))
	}
	return n
}

func (m *Request) Size() (n int) {
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovRpc(uint64(m.Operation))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Tester != nil {
		l = m.Tester.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}

func sovRpc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Etcd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Etcd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Etcd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WALDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WALDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatIntervalMs", wireType)
			}
			m.HeartbeatIntervalMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatIntervalMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionTimeoutMs", wireType)
			}
			m.ElectionTimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectionTimeoutMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenClientURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenClientURLs = append(m.ListenClientURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseClientURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertiseClientURLs = append(m.AdvertiseClientURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAutoTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClientAutoTLS = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertAuth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClientCertAuth = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTrustedCAFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientTrustedCAFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenPeerURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenPeerURLs = append(m.ListenPeerURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertisePeerURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvertisePeerURLs = append(m.AdvertisePeerURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAutoTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeerAutoTLS = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerClientCertAuth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PeerClientCertAuth = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCertFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerCertFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerKeyFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerKeyFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerTrustedCAFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerTrustedCAFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialClusterState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialClusterState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialClusterToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialClusterToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotCount", wireType)
			}
			m.SnapshotCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuotaBackendBytes", wireType)
			}
			m.QuotaBackendBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuotaBackendBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 63:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreVote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreVote = bool(v != 0)
		case 64:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialCorruptCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitialCorruptCheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdExecPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EtcdExecPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailpointHTTPAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailpointHTTPAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdLogPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EtcdLogPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdClientTLS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EtcdClientTLS = bool(v != 0)
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdClientProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EtcdClientProxy = bool(v != 0)
		case 203:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdPeerProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EtcdPeerProxy = bool(v != 0)
		case 204:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdClientEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EtcdClientEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etcd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Etcd == nil {
				m.Etcd = &Etcd{}
			}
			if err := m.Etcd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 401:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCertData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCertData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 402:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKeyData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientKeyData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 403:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientTrustedCAData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientTrustedCAData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 501:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCertData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerCertData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 502:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerKeyData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerKeyData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 503:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerTrustedCAData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerTrustedCAData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tester) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tester: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tester: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TesterNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TesterNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TesterAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TesterAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayLatencyMs", wireType)
			}
			m.DelayLatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayLatencyMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayLatencyMsRv", wireType)
			}
			m.DelayLatencyMsRv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayLatencyMsRv |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDelayLatencyMs", wireType)
			}
			m.UpdatedDelayLatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedDelayLatencyMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundLimit", wireType)
			}
			m.RoundLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoundLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExitOnFailure = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsistencyCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsistencyCheck = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnablePprof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnablePprof = bool(v != 0)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureCases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureCases = append(m.FailureCases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureDelayMs", wireType)
			}
			m.FailureDelayMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureDelayMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureShuffle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FailureShuffle = bool(v != 0)
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailpointCommands", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailpointCommands = append(m.FailpointCommands, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunnerExecPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunnerExecPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalExecPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalExecPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StressTypes = append(m.StressTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressKeySize", wireType)
			}
			m.StressKeySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressKeySize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressKeySizeLarge", wireType)
			}
			m.StressKeySizeLarge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressKeySizeLarge |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 104:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressKeySuffixRange", wireType)
			}
			m.StressKeySuffixRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressKeySuffixRange |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 105:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressKeySuffixRangeTxn", wireType)
			}
			m.StressKeySuffixRangeTxn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressKeySuffixRangeTxn |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 106:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressKeyTxnOps", wireType)
			}
			m.StressKeyTxnOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressKeyTxnOps |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressClients", wireType)
			}
			m.StressClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StressQPS", wireType)
			}
			m.StressQPS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StressQPS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= (Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tester", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tester == nil {
				m.Tester = &Tester{}
			}
			if err := m.Tester.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rpcpb/rpc.proto", fileDescriptorRpc) }

var fileDescriptorRpc = []byte{
	// 2404 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x59, 0xcb, 0x76, 0xdb, 0xc8,
	0xd1, 0x16, 0x44, 0x4b, 0x23, 0xb5, 0x6e, 0x54, 0xcb, 0xb2, 0x60, 0x7b, 0x46, 0x94, 0xe1, 0xf1,
	0xfc, 0x1a, 0xfd, 0x81, 0x9c, 0xd8, 0x73, 0x92, 0xd8, 0x73, 0xb1, 0x29, 0x0a, 0xb6, 0x18, 0x41,
	0x24, 0xdd, 0x84, 0x6c, 0xcf, 0x8a, 0x81, 0xc0, 0xa6, 0x88, 0x08, 0x02, 0x68, 0xa0, 0xa9, 0xa1,
	0xe6, 0x05, 0xb2, 0xcd, 0x65, 0x93, 0x87, 0xc8, 0x2c, 0xf3, 0x0e, 0x9e, 0x4b, 0x92, 0x49, 0xb2,
	0xcb, 0x82, 0x49, 0x9c, 0x93, 0x17, 0xe0, 0xc9, 0xe5, 0x64, 0x97, 0xd3, 0x17, 0x90, 0x0d, 0x90,
	0x94, 0xbd, 0x63, 0x57, 0x7d, 0xdf, 0x87, 0xee, 0xaa, 0x46, 0x55, 0x41, 0x02, 0x4b, 0x61, 0xcb,
	0x69, 0x1d, 0xdd, 0x0e, 0x5b, 0xce, 0x76, 0x2b, 0x0c, 0x48, 0x00, 0xa7, 0x98, 0xe1, 0x9a, 0x7e,
	0xec, 0x92, 0x66, 0xfb, 0x68, 0xdb, 0x09, 0x4e, 0x6f, 0x1f, 0x07, 0xc7, 0xc1, 0x6d, 0xe6, 0x3d,
	0x6a, 0x37, 0xd8, 0x8a, 0x2d, 0xd8, 0x2f, 0xce, 0xd2, 0xfe, 0xbb, 0x00, 0x2e, 0x19, 0xc4, 0xa9,
	0xc3, 0x9b, 0xe0, 0x52, 0xc9, 0x3e, 0xc5, 0xaa, 0xb2, 0xa1, 0x6c, 0xce, 0xee, 0x2c, 0xf5, 0xba,
	0xb9, 0xb9, 0x73, 0xfb, 0xd4, 0xbb, 0xaf, 0xf9, 0xf6, 0x29, 0xd6, 0x10, 0x73, 0x42, 0x1d, 0xbc,
	0xb5, 0x6b, 0x13, 0x7b, 0xd7, 0x0d, 0xd5, 0x49, 0x86, 0x5b, 0xe9, 0x75, 0x73, 0x4b, 0x1c, 0x57,
	0xb7, 0x89, 0xad, 0xd7, 0xdd, 0x50, 0x43, 0x31, 0x06, 0x6e, 0x81, 0xe9, 0x67, 0x79, 0x93, 0xa2,
	0x33, 0x0c, 0x0d, 0x7b, 0xdd, 0xdc, 0x22, 0x47, 0x7f, 0x66, 0x7b, 0x1c, 0x2c, 0x10, 0xb0, 0x0c,
	0x56, 0xf6, 0xb0, 0x1d, 0x92, 0x23, 0x6c, 0x93, 0xa2, 0x4f, 0x70, 0x78, 0x66, 0x7b, 0x07, 0x91,
	0x3a, 0xb7, 0xa1, 0x6c, 0x66, 0x76, 0xde, 0xe9, 0x75, 0x73, 0x57, 0x39, 0xb1, 0x19, 0x83, 0x74,
	0x57, 0xa0, 0x34, 0x34, 0x8a, 0x09, 0x8b, 0x60, 0xd9, 0xf0, 0xb0, 0x43, 0xdc, 0xc0, 0xb7, 0xdc,
	0x53, 0x1c, 0xb4, 0xc9, 0x41, 0xa4, 0xce, 0x33, 0xb9, 0xeb, 0xbd, 0x6e, 0x6e, 0x8d, 0xcb, 0x61,
	0x01, 0xd1, 0x09, 0xc7, 0x68, 0x68, 0x98, 0x05, 0x8b, 0x20, 0x6b, 0xba, 0x11, 0xc1, 0x7e, 0xc1,
	0x73, 0xb1, 0x4f, 0x0e, 0x91, 0x19, 0xa9, 0xab, 0x1b, 0x99, 0xcd, 0x59, 0x79, 0x63, 0x1e, 0x43,
	0xe8, 0x0e, 0x83, 0xe8, 0xed, 0xd0, 0x8b, 0x34, 0x34, 0x44, 0x83, 0x08, 0xac, 0xe4, 0xeb, 0x67,
	0x38, 0x24, 0x6e, 0x84, 0x25, 0xb5, 0x2b, 0x4c, 0x6d, 0xa3, 0xd7, 0xcd, 0xbd, 0xcd, 0xd5, 0xec,
	0x18, 0x94, 0x14, 0x1c, 0x45, 0x86, 0xf7, 0xc0, 0x02, 0x5f, 0xe5, 0xdb, 0x24, 0xb0, 0xcc, 0xaa,
	0xba, 0xb6, 0xa1, 0x6c, 0xce, 0xc8, 0xb9, 0xb1, 0xdb, 0x24, 0xd0, 0x09, 0x15, 0x48, 0x22, 0x61,
	0x01, 0x2c, 0x72, 0x43, 0x01, 0x87, 0xd4, 0xd8, 0x54, 0x55, 0xc6, 0x95, 0x22, 0x24, 0x9e, 0xef,
	0xe0, 0x90, 0xe8, 0x76, 0x9b, 0x34, 0x35, 0x94, 0xa2, 0xc0, 0x8f, 0x64, 0x91, 0x47, 0xae, 0x87,
	0xd5, 0xab, 0x2c, 0xdd, 0x97, 0x7b, 0xdd, 0x5c, 0x56, 0x88, 0x50, 0x76, 0xc3, 0xf5, 0x70, 0x82,
	0x4d, 0xb1, 0x83, 0xdd, 0xef, 0xe3, 0x73, 0x46, 0xbe, 0x96, 0xbe, 0x59, 0x27, 0xf8, 0x5c, 0x70,
	0x93, 0x48, 0x68, 0x82, 0x15, 0x6e, 0xb0, 0xc2, 0x76, 0x44, 0x70, 0xbd, 0x90, 0x67, 0x02, 0xd7,
	0x99, 0xc0, 0xb5, 0x5e, 0x37, 0x77, 0x85, 0x0b, 0x10, 0xee, 0xd6, 0x1d, 0x5b, 0xe8, 0x8c, 0xa2,
	0xd1, 0x58, 0xf0, 0x74, 0x55, 0x30, 0x0e, 0x59, 0x56, 0x72, 0x2c, 0x2b, 0x52, 0x2c, 0x44, 0x8e,
	0x5b, 0x18, 0x87, 0x22, 0x21, 0x29, 0x0a, 0xb4, 0xc0, 0x72, 0x3f, 0x45, 0x7d, 0x9d, 0x0d, 0xa6,
	0xf3, 0x5e, 0xaf, 0x9b, 0xd3, 0xb8, 0x8e, 0xeb, 0xbb, 0xc4, 0xb5, 0x3d, 0x7d, 0x90, 0x65, 0x49,
	0x72, 0x58, 0x00, 0xde, 0x07, 0x73, 0xf4, 0x77, 0x9c, 0xdf, 0x1b, 0x2c, 0x47, 0x6a, 0xaf, 0x9b,
	0xbb, 0xcc, 0xf5, 0x18, 0x7b, 0x90, 0x64, 0x19, 0x0c, 0x2b, 0x00, 0xd2, 0x65, 0x2a, 0xcd, 0x1a,
	0x93, 0x90, 0x2e, 0x1c, 0x93, 0x18, 0xce, 0xf5, 0x08, 0x2e, 0xfc, 0x18, 0xcc, 0x33, 0x6b, 0x9c,
	0xed, 0x9b, 0x2c, 0xde, 0x57, 0x7b, 0xdd, 0xdc, 0xaa, 0xac, 0x35, 0x48, 0x79, 0x02, 0x1e, 0x1f,
	0x26, 0x4e, 0xf7, 0xbb, 0x8c, 0x9d, 0x3e, 0xcc, 0x20, 0xe7, 0x32, 0x18, 0x1e, 0x80, 0x65, 0xba,
	0x4c, 0xe6, 0xfb, 0x16, 0x53, 0xc8, 0xf5, 0xba, 0xb9, 0xeb, 0x92, 0xc2, 0x50, 0xd2, 0x87, 0x99,
	0x70, 0x07, 0x2c, 0x16, 0x79, 0x2a, 0x0a, 0x1e, 0xb5, 0x87, 0xea, 0xfb, 0xe9, 0xbb, 0x13, 0xa7,
	0xca, 0xe1, 0x00, 0x0d, 0xa5, 0x18, 0xf4, 0x8d, 0x4e, 0x5a, 0xaa, 0xc4, 0x26, 0x58, 0xdd, 0x62,
	0x42, 0x52, 0x80, 0x53, 0x42, 0x7a, 0x44, 0x61, 0x1a, 0x1a, 0x45, 0x1e, 0xd6, 0xb4, 0x82, 0x13,
	0xec, 0xab, 0xff, 0xff, 0x3a, 0x4d, 0x42, 0x61, 0x43, 0x9a, 0x8c, 0x0c, 0x1f, 0x80, 0x85, 0xaa,
	0x6f, 0xb7, 0xa2, 0x66, 0x40, 0x0a, 0x41, 0xdb, 0x27, 0xea, 0x5d, 0x56, 0x0b, 0xa5, 0xb4, 0x45,
	0xc2, 0xad, 0x3b, 0xd4, 0xaf, 0xa1, 0x24, 0x1e, 0x9a, 0x60, 0xf9, 0x49, 0x3b, 0x20, 0xf6, 0x8e,
	0xed, 0x9c, 0x60, 0xbf, 0xbe, 0x73, 0x4e, 0x70, 0xa4, 0x7e, 0xc0, 0x44, 0xd6, 0x7b, 0xdd, 0xdc,
	0x35, 0x2e, 0xf2, 0x82, 0x42, 0xf4, 0x23, 0x8e, 0xd1, 0x8f, 0x28, 0x48, 0x43, 0xc3, 0x44, 0xda,
	0x4a, 0x2a, 0x21, 0x7e, 0x1a, 0x10, 0xac, 0x3e, 0x48, 0x97, 0xab, 0x56, 0x88, 0xf5, 0xb3, 0x80,
	0x46, 0x27, 0xc6, 0xc8, 0x11, 0x09, 0xc2, 0xb0, 0xdd, 0x22, 0x85, 0x26, 0x76, 0x4e, 0xd4, 0x87,
	0xe9, 0x6b, 0xdc, 0x8f, 0x08, 0x47, 0xe9, 0x0e, 0x85, 0x49, 0x11, 0x91, 0xc8, 0xda, 0x6f, 0x66,
	0xc0, 0xf4, 0x01, 0x3e, 0x3d, 0xc2, 0x21, 0xbd, 0xd2, 0xb4, 0x0b, 0x1a, 0x1d, 0xec, 0x54, 0x6c,
	0xd2, 0x14, 0x5d, 0x50, 0x8a, 0x0d, 0x26, 0x4e, 0x5d, 0xc7, 0x1d, 0xec, 0xe8, 0x2d, 0x9b, 0xbe,
	0x17, 0x09, 0x38, 0xbc, 0x0b, 0x66, 0xf3, 0xc7, 0xb4, 0xac, 0xd6, 0xeb, 0x21, 0x6b, 0x59, 0xb3,
	0x3b, 0xab, 0xbd, 0x6e, 0x6e, 0x59, 0x54, 0x5f, 0xea, 0xd2, 0xed, 0x7a, 0x3d, 0xd4, 0xd0, 0x00,
	0x47, 0xe3, 0xf9, 0xc8, 0x76, 0xbd, 0x56, 0xe0, 0xfa, 0x64, 0xcf, 0xb2, 0x2a, 0x8c, 0x3c, 0xcf,
	0xc8, 0x52, 0x3c, 0x1b, 0x31, 0x44, 0x6f, 0x12, 0xd2, 0x12, 0x2a, 0xc3, 0x44, 0x1a, 0xcf, 0x1d,
	0x3b, 0xc2, 0xb4, 0xd9, 0xe2, 0x74, 0x01, 0x3d, 0xb2, 0x23, 0x2c, 0x5a, 0xb3, 0xc0, 0xd0, 0x97,
	0x90, 0x9e, 0xc0, 0x0c, 0x8e, 0xd9, 0x79, 0x1b, 0xe9, 0x97, 0x90, 0x9d, 0xd7, 0x0b, 0x8e, 0xc5,
	0x71, 0x65, 0x30, 0xcc, 0x83, 0x05, 0xba, 0x14, 0x35, 0xd4, 0xac, 0xaa, 0x5f, 0x2a, 0x2c, 0x0d,
	0xd2, 0x5b, 0xc3, 0xe8, 0xa2, 0x9a, 0xf0, 0xbe, 0x93, 0x60, 0xc0, 0xc7, 0x60, 0x69, 0x60, 0xa8,
	0x84, 0x41, 0xe7, 0x5c, 0xfd, 0x8a, 0x8b, 0xbc, 0xdd, 0xeb, 0xe6, 0xd4, 0x61, 0x91, 0x16, 0xc5,
	0x68, 0x28, 0xcd, 0x8a, 0xf7, 0x42, 0x5f, 0x6d, 0x2e, 0xf3, 0xf5, 0xe8, 0xbd, 0xb0, 0x92, 0x20,
	0x44, 0x92, 0x0c, 0x5a, 0x20, 0x07, 0xaa, 0x86, 0x5f, 0x67, 0x71, 0x55, 0xbf, 0x51, 0xd2, 0x55,
	0x45, 0xde, 0x0e, 0x16, 0x30, 0x0d, 0x8d, 0xe0, 0xc2, 0xef, 0xf1, 0x99, 0x4a, 0xfd, 0x82, 0x0e,
	0x49, 0x73, 0x77, 0xe6, 0xb6, 0xd9, 0x68, 0xb6, 0x4d, 0x6d, 0xf2, 0x64, 0x45, 0x05, 0x35, 0xc4,
	0xc7, 0xaf, 0x5d, 0xb9, 0x87, 0xd2, 0xf9, 0x49, 0xfd, 0x39, 0x9f, 0x99, 0xc6, 0x74, 0x62, 0x3a,
	0x6d, 0x25, 0x7a, 0x29, 0xe5, 0xd0, 0x68, 0xf4, 0x3b, 0x24, 0x13, 0xf9, 0x45, 0x26, 0x5d, 0xcf,
	0x84, 0x08, 0xad, 0xaf, 0x5c, 0x23, 0xc9, 0x80, 0xd6, 0x50, 0x4f, 0x65, 0x42, 0xbf, 0xe4, 0x42,
	0x37, 0x7a, 0xdd, 0xdc, 0x3b, 0x09, 0x21, 0xa9, 0xcc, 0x72, 0xbd, 0x51, 0x74, 0xf8, 0xc9, 0xa0,
	0x65, 0x30, 0xb9, 0x7f, 0x65, 0xc6, 0xf7, 0x0c, 0x2e, 0x93, 0xc0, 0xc3, 0x0f, 0xfb, 0x3d, 0x83,
	0xd1, 0xff, 0x9d, 0x19, 0xdb, 0x34, 0x38, 0x5b, 0x46, 0xc3, 0x52, 0xaa, 0x69, 0x30, 0x89, 0xff,
	0x64, 0x5e, 0xd7, 0x35, 0xb8, 0xd2, 0x30, 0x55, 0xfb, 0xf3, 0x3c, 0x98, 0xb6, 0x30, 0x2b, 0xfe,
	0x0f, 0xc0, 0x02, 0xff, 0x55, 0xc2, 0xe4, 0xb3, 0x20, 0x3c, 0x19, 0x2e, 0x1c, 0x84, 0xb9, 0x75,
	0x9f, 0xfb, 0x35, 0x94, 0xc4, 0xc3, 0xef, 0x03, 0xc0, 0x0d, 0xec, 0xed, 0xe7, 0x43, 0xf5, 0x95,
	0x5e, 0x37, 0x07, 0x13, 0x6c, 0xfe, 0xd6, 0x4b, 0x48, 0x3a, 0xac, 0xec, 0x62, 0xcf, 0x3e, 0x37,
	0x6d, 0x82, 0x7d, 0xe7, 0x5c, 0x4c, 0xca, 0x0b, 0xf2, 0x75, 0xa9, 0x53, 0xbf, 0xee, 0x71, 0x80,
	0x7e, 0x4a, 0x87, 0x95, 0x24, 0x05, 0xfe, 0x08, 0x64, 0x93, 0x16, 0x74, 0xc6, 0x0a, 0xd0, 0x82,
	0x5c, 0x80, 0xd2, 0x32, 0x7a, 0x78, 0xa6, 0xa1, 0x21, 0x1e, 0xfc, 0x14, 0xac, 0x1e, 0xb6, 0xea,
	0x36, 0xc1, 0xf5, 0xd4, 0xbe, 0x16, 0x98, 0xe0, 0xcd, 0x5e, 0x37, 0x97, 0xe3, 0x82, 0x6d, 0x0e,
	0xd3, 0x87, 0xf7, 0x37, 0x5a, 0x81, 0xc6, 0x08, 0x05, 0x6d, 0xbf, 0x6e, 0xba, 0xa7, 0x2e, 0x51,
	0x57, 0x37, 0x94, 0xcd, 0x29, 0x39, 0x46, 0x21, 0xf5, 0xe9, 0x1e, 0x75, 0x6a, 0x48, 0x42, 0xc2,
	0x87, 0x60, 0xc1, 0xe8, 0xb8, 0xa4, 0xec, 0xd3, 0x6a, 0xd9, 0x0e, 0xb1, 0x7a, 0x65, 0xa8, 0x34,
	0x74, 0x5c, 0xa2, 0x07, 0xbe, 0xde, 0xe0, 0x00, 0x5a, 0x1a, 0x64, 0x02, 0xdc, 0x03, 0xd9, 0x42,
	0xe0, 0x47, 0x6c, 0xc4, 0x73, 0xce, 0x79, 0xcb, 0x59, 0x4b, 0x97, 0x29, 0x67, 0x80, 0x88, 0xdb,
	0xcd, 0x10, 0x0b, 0xde, 0x03, 0x73, 0x86, 0x6f, 0x1f, 0x79, 0xb8, 0xd2, 0x0a, 0x83, 0x86, 0x98,
	0xb2, 0xd7, 0x7a, 0xdd, 0xdc, 0x8a, 0xd8, 0x09, 0x73, 0xea, 0x2d, 0xea, 0xa5, 0xe5, 0x76, 0x80,
	0x85, 0x1f, 0x81, 0x79, 0xb1, 0x9f, 0x82, 0x1d, 0xe1, 0x78, 0x2a, 0x95, 0xee, 0xbe, 0xd8, 0xbd,
	0xee, 0x50, 0xb7, 0x86, 0x12, 0x68, 0x7a, 0x51, 0xc4, 0x9a, 0x45, 0xf5, 0x80, 0x4e, 0xa3, 0xa9,
	0x8b, 0x12, 0xf3, 0x79, 0x42, 0xd8, 0x45, 0x49, 0x52, 0xe8, 0x9c, 0x24, 0x2c, 0xd5, 0x66, 0xbb,
	0xd1, 0xf0, 0xb0, 0x18, 0x41, 0xa5, 0x50, 0xc6, 0x22, 0x11, 0x07, 0x0c, 0x34, 0x04, 0x03, 0xee,
	0x4b, 0xed, 0xae, 0x10, 0x9c, 0x9e, 0xda, 0x7e, 0x3d, 0x52, 0xb5, 0xf4, 0x57, 0xd4, 0xa0, 0xdd,
	0x39, 0x02, 0x23, 0x77, 0xbb, 0x98, 0x47, 0x4f, 0x85, 0xda, 0xbe, 0x8f, 0xc3, 0x7e, 0xc7, 0x7e,
	0x3f, 0x5d, 0x2d, 0x43, 0xe6, 0x97, 0x7b, 0x76, 0x8a, 0x42, 0x3f, 0xeb, 0x8c, 0x0e, 0xc1, 0xa1,
	0x6f, 0x7b, 0x7d, 0x19, 0x3e, 0xb6, 0x49, 0x1b, 0xc2, 0x02, 0x21, 0x0b, 0x0d, 0xd1, 0x68, 0x7a,
	0xab, 0x24, 0xc4, 0x51, 0x64, 0x9d, 0xb7, 0x70, 0xa4, 0x62, 0x76, 0x2c, 0x29, 0xbd, 0x11, 0x73,
	0xea, 0x84, 0x7a, 0x35, 0x24, 0x63, 0xe9, 0x2d, 0xe5, 0xcb, 0x7d, 0x7c, 0x5e, 0x75, 0x3f, 0xc7,
	0xac, 0x17, 0x4f, 0xc9, 0xa1, 0x15, 0x64, 0x5a, 0xdd, 0x22, 0xf7, 0x73, 0x7a, 0x4b, 0x13, 0x04,
	0xda, 0xc0, 0x12, 0x06, 0xd3, 0x0e, 0x8f, 0xb1, 0x7a, 0xcc, 0x64, 0xa4, 0xd1, 0x28, 0x25, 0xa3,
	0x7b, 0x14, 0xa6, 0xa1, 0x11, 0x5c, 0xf8, 0x14, 0x5c, 0x1e, 0x58, 0xdb, 0x8d, 0x86, 0xdb, 0x41,
	0xb6, 0x7f, 0x8c, 0xd5, 0x26, 0xd3, 0xd4, 0x7a, 0xdd, 0xdc, 0xfa, 0xb0, 0x26, 0xc3, 0xe9, 0x21,
	0x05, 0x6a, 0x68, 0x24, 0x1f, 0xfe, 0x18, 0xac, 0x8d, 0xb2, 0x5b, 0x1d, 0x5f, 0x75, 0x99, 0xb4,
	0xf4, 0x8d, 0x34, 0x46, 0x5a, 0x27, 0x1d, 0x5f, 0x43, 0xe3, 0x64, 0xe8, 0x60, 0xd1, 0x77, 0x59,
	0x1d, 0xbf, 0xdc, 0x8a, 0xd4, 0x9f, 0x30, 0x65, 0x29, 0xa5, 0x92, 0x32, 0xe9, 0xf8, 0x7a, 0xd0,
	0x8a, 0x34, 0x94, 0x66, 0x0d, 0xd2, 0xc2, 0xdb, 0x59, 0xc4, 0x87, 0x9c, 0xa9, 0xc4, 0xbc, 0xcc,
	0x75, 0x78, 0x23, 0x8c, 0xfa, 0x69, 0x11, 0x04, 0xf8, 0x01, 0x98, 0xe5, 0x86, 0x27, 0x95, 0x2a,
	0x9f, 0x6e, 0xa6, 0xe4, 0xa9, 0x50, 0xb0, 0x5f, 0xd0, 0xa7, 0x0f, 0x80, 0xda, 0x4f, 0x15, 0xf0,
	0x16, 0xc2, 0x2f, 0xda, 0x38, 0x22, 0x70, 0x1b, 0xcc, 0x96, 0x5b, 0x38, 0xb4, 0x89, 0x1b, 0xf8,
	0xac, 0xb3, 0x2c, 0xde, 0xc9, 0x8a, 0x59, 0xa2, 0x6f, 0x47, 0x03, 0x08, 0xbc, 0x15, 0xcf, 0xb3,
	0x2a, 0x1f, 0x3c, 0x16, 0x04, 0x98, 0x1b, 0x51, 0x3c, 0xec, 0xde, 0x8a, 0xdb, 0x17, 0xfb, 0xb3,
	0xcc, 0x00, 0xc6, 0x8d, 0x48, 0x38, 0x35, 0x07, 0xcc, 0x20, 0x1c, 0xb5, 0x02, 0x3f, 0xc2, 0x50,
	0x05, 0x6f, 0x55, 0xdb, 0x8e, 0x83, 0xa3, 0x88, 0xed, 0x63, 0x06, 0xc5, 0x4b, 0x78, 0x05, 0x4c,
	0xd3, 0x6f, 0x96, 0x76, 0xc4, 0x9b, 0x17, 0x12, 0x2b, 0x69, 0x2f, 0x99, 0x0b, 0xf6, 0xb2, 0xf5,
	0x17, 0x45, 0x3a, 0x23, 0x5c, 0x04, 0xa0, 0x14, 0x90, 0x2a, 0xb1, 0x43, 0x82, 0xeb, 0xd9, 0x09,
	0x78, 0x19, 0x64, 0xc5, 0xe0, 0xce, 0x6c, 0x74, 0x52, 0xca, 0x2a, 0x70, 0x09, 0xcc, 0x21, 0x1c,
	0xf5, 0x0d, 0x93, 0x70, 0x1e, 0xcc, 0xec, 0xbb, 0x9e, 0xc7, 0x56, 0x19, 0xea, 0xa6, 0x05, 0x23,
	0x1f, 0x3a, 0x4d, 0xf7, 0x0c, 0x67, 0x2f, 0x51, 0x95, 0x5d, 0x1c, 0x91, 0x30, 0x38, 0xa7, 0x08,
	0x36, 0x80, 0x67, 0xa7, 0xe0, 0x55, 0xb0, 0xba, 0xe3, 0xd9, 0xce, 0x49, 0x33, 0xf0, 0xd8, 0x87,
	0x76, 0x25, 0x08, 0x89, 0xd5, 0x41, 0x9d, 0x6c, 0x1d, 0x5e, 0x07, 0x6b, 0x87, 0xfe, 0xd1, 0x48,
	0x27, 0x86, 0xab, 0x60, 0x99, 0x95, 0xc5, 0x84, 0xb9, 0x01, 0xd7, 0xc0, 0xca, 0xa1, 0x5f, 0x1f,
	0x72, 0x1c, 0x6f, 0xfd, 0x63, 0x86, 0xef, 0x47, 0x54, 0x64, 0xca, 0xdf, 0x2f, 0x9a, 0x66, 0xad,
	0x5c, 0x32, 0x6a, 0x8f, 0xca, 0xa6, 0x59, 0x7e, 0x66, 0xa0, 0xec, 0x04, 0xfc, 0x0e, 0xd8, 0x1c,
	0x32, 0xd7, 0x0e, 0x4b, 0x56, 0xd1, 0xac, 0x59, 0xa8, 0xf8, 0xf8, 0xb1, 0x81, 0x6a, 0xd5, 0x52,
	0xbe, 0x52, 0xdd, 0x2b, 0x5b, 0x3c, 0x04, 0x0c, 0x6d, 0x1a, 0xf9, 0x5d, 0x03, 0x65, 0x27, 0xe1,
	0x7b, 0x40, 0x93, 0x0c, 0xe3, 0x88, 0x99, 0x3e, 0xf1, 0xc9, 0x61, 0x19, 0x1d, 0x1e, 0x64, 0x2f,
	0xb1, 0xd8, 0x51, 0x43, 0xde, 0x34, 0xb3, 0x53, 0x70, 0x0b, 0xbc, 0xb7, 0x63, 0xe6, 0x0b, 0xfb,
	0x7b, 0x65, 0xd3, 0xa8, 0x55, 0x0c, 0x03, 0xd5, 0x2a, 0x65, 0x64, 0xd5, 0xac, 0xe7, 0x35, 0xf4,
	0x3c, 0xb9, 0xe3, 0x3a, 0xcc, 0x83, 0x8f, 0xdf, 0x0c, 0x3b, 0x6e, 0x37, 0x18, 0xbe, 0x0b, 0x36,
	0xc6, 0x4b, 0x88, 0xb3, 0x35, 0xe0, 0x87, 0xe0, 0x07, 0xaf, 0x43, 0x8d, 0x7b, 0xc4, 0xf1, 0xc5,
	0x8f, 0x10, 0x51, 0x68, 0xc2, 0x1b, 0xe0, 0x9d, 0xf1, 0x28, 0x1a, 0x1a, 0x17, 0xfe, 0x1f, 0xd0,
	0x76, 0x0d, 0x33, 0xff, 0xe9, 0xc5, 0x61, 0x79, 0xa9, 0xc0, 0x6d, 0xf0, 0x3e, 0xca, 0x97, 0x76,
	0xcb, 0x07, 0xb5, 0x37, 0xc0, 0x7f, 0xa9, 0xc0, 0x4f, 0xc0, 0xbd, 0xd7, 0x03, 0xc7, 0x1d, 0xf0,
	0x2b, 0x05, 0x1a, 0xe0, 0xe1, 0x1b, 0x3f, 0x6f, 0x9c, 0xcc, 0xd7, 0x0a, 0xbc, 0x01, 0xde, 0x1e,
	0xcd, 0x17, 0x79, 0xf8, 0x46, 0x81, 0x9b, 0xe0, 0xe6, 0x85, 0x4f, 0x12, 0xc8, 0xdf, 0x2a, 0xf0,
	0x87, 0xe0, 0xee, 0x45, 0x90, 0x71, 0xdb, 0xf8, 0x9d, 0x02, 0x1f, 0x80, 0xfb, 0x6f, 0xf0, 0x8c,
	0x71, 0x02, 0xbf, 0xbf, 0xe0, 0x1c, 0x22, 0xd9, 0xdf, 0xbe, 0xfe, 0x1c, 0x02, 0xf9, 0x07, 0x05,
	0xae, 0x83, 0xab, 0xa3, 0x21, 0xf4, 0x4e, 0xfc, 0x51, 0x81, 0xb7, 0xc0, 0xc6, 0x85, 0x4a, 0x14,
	0xf6, 0x27, 0x05, 0xaa, 0x60, 0xa5, 0x54, 0xae, 0x3d, 0xca, 0x17, 0xcd, 0xda, 0xb3, 0xa2, 0xb5,
	0x57, 0xab, 0x5a, 0xc8, 0xa8, 0x56, 0xb3, 0xbf, 0x9e, 0xa4, 0x5b, 0x49, 0x78, 0x4a, 0x65, 0xe1,
	0xac, 0x3d, 0x2a, 0xa3, 0x9a, 0x59, 0x7c, 0x6a, 0x94, 0x28, 0xf2, 0x8b, 0x49, 0xb8, 0x04, 0x00,
	0x85, 0x55, 0xca, 0xc5, 0x92, 0x55, 0xcd, 0xfe, 0x2c, 0x03, 0x17, 0xc0, 0x8c, 0xf1, 0xdc, 0x32,
	0x50, 0x29, 0x6f, 0x66, 0xff, 0x99, 0xd9, 0x0a, 0x00, 0x18, 0x8c, 0x15, 0x70, 0x1a, 0x4c, 0xee,
	0x3f, 0xcd, 0x4e, 0xc0, 0x59, 0x30, 0x65, 0x1a, 0xf9, 0xaa, 0x91, 0x55, 0xe0, 0x0a, 0x58, 0x32,
	0x4c, 0xa3, 0x60, 0x15, 0xcb, 0xa5, 0x1a, 0x3a, 0x2c, 0x95, 0x58, 0xdd, 0xc8, 0x82, 0xf9, 0x67,
	0x79, 0xab, 0xb0, 0x17, 0x5b, 0x32, 0xb4, 0x3e, 0x99, 0xe5, 0xc2, 0x7e, 0x0d, 0xe5, 0x0b, 0x06,
	0x8a, 0xcd, 0x97, 0x28, 0x90, 0x09, 0xc5, 0x96, 0xa9, 0x3b, 0x0f, 0xc0, 0xac, 0x15, 0xda, 0x7e,
	0xd4, 0x0a, 0x42, 0x02, 0xef, 0xc8, 0x8b, 0x45, 0x51, 0xeb, 0x45, 0x1f, 0xbb, 0xb6, 0xd4, 0x5f,
	0xf3, 0x76, 0xa2, 0x4d, 0x6c, 0x2a, 0xdf, 0x55, 0x76, 0x2e, 0xbf, 0xfc, 0xdb, 0xfa, 0xc4, 0xcb,
	0x57, 0xeb, 0xca, 0xb7, 0xaf, 0xd6, 0x95, 0xbf, 0xbe, 0x5a, 0x57, 0x7e, 0xf5, 0xf7, 0xf5, 0x89,
	0xa3, 0x69, 0xf6, 0x8f, 0x89, 0xbb, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x9e, 0x8b, 0x82, 0xf1,
	0xe1, 0x18, 0x00, 0x00,
}
